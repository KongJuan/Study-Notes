### **快速开发框架** **Spring Cloud**

#### **第** **1** **次直播课**

【Q-01】你曾阅读过 Spring Cloud 的源码吗？我们知道，Spring Cloud 是通过 Spring Boot 集成了很多第三方框架构成的。现在准备解析 Spring Cloud 中某子框架的源码，若还没有找到合适的入手位置，那么从哪里开始解析可能是一个不错的选择？

【RA】我自己曾阅读过 Spring Cloud 中的 Eureka、OpenFeign、Ribbon 等的源码。对于一个未曾阅读过的子框架源码，我认为**从自动配置类开始解析**可能是一个不错的选择。

​        我们知道 **Spring Cloud 是通过 Spring Boot 将其它第三方框架集成进来的**。**Spring Boot 最大的特点就是自动配置**，我们可以通过导入相关 Starter 来实现需求功能的自动配置、相关核心业务类实例的创建等。也就是说，核心业务类都是集中在自动配置类中的。所以从这里下手分析应该是个不错的选择。

​        那么从哪里可以找到这个自动配置类呢？从导入的 starter 依赖工程的 META-INF 目录中的 spring.factory 文件中 可以找到。该文件的内容为 key-value 对，查找 **EnableAutoConfiguration的全限定性类名**作为 key 的 value，这个 value 就是我们要找到的自动配置类。

【Q-02】@EnableConfigurationProperties 注解对于 Starter 的定义很重要，请谈一下你对这个注解的认识。 

【RA】@EnableConfigurationProperties 注解在 Starter 定义时主要用于读取 application.yml 配置文件中相关的属性，并封装到指定类型的实例中，以备 Starter 中的核心业务实例使用。

具体来说，它就是开启了对@ConfigurationProperties 注解的 Bean 的自动注册，注解到Spring 容器中。这种 Bean 有两种注册方式：在配置类使用@Bean 方法注册，或直接使用该注解的 value 属性进行注册。若在配置类中使用@Bean 注册，则需要在配置类中定义一个@Bean 方法，该方法的返回值为“使用@ConfigurationProperties 注解标注”的类。若直接使用该注解的 value 属性进行注册，则需要将这个“使用@ConfigurationProperties 注解标注”的类作为 value 属性值出现即可。

【Q-03】Spring Boot 中定义了很多条件注解，这些注解一般用于对配置类的控制。在这些条

件注解中有一个@ConditionalOnMissingBean 注解，你了解过嘛？请谈一下你对它的认识。

【RA】@ConditionalOnMissingBean 注解是 Spring Boot 提供的众多条件注册中的一个。其表

示的意义是，当容器中没有指定名称或指定类型的 Bean 时，该条件为 true。不过，这里需

要强调一点的是，这里要查找的“容器”是可以指定的。通过 search 属性指定。其 search

的范围有三种：仅搜索当前配置类容器；搜索所有层次的父类容器，但不包含当前配置类容

器；搜索当前配置类容器及其所有层次的父类容器，这个是默认搜索范围。

【Q-04】Spring Cloud 中默认情况下对于 Eureka Client 实例的创建中，@RefreshScope 注解是

比较重要的，请谈一下你对这个注解的认识。

【RA】@RefreshScope 注解是 Spring Cloud 中定义的一个注解。该注解用于配置类，可以添 开课吧 Reythor 雷课程知识点暨面试题总结

讲师：Reythor 雷 

2

加在配置类上，也可以添加在@Bean 方法上。其表示的意思是，该@Bean 方法会以多例的

形式生成会自动刷新的 Bean 实例。这种方式就等价于在 Spring的 xml 配置文件中指定<bean/>

标签的 scope 属性值为 refresh。当然，若一个配置类上添加了该注解，则表示该配置类中的

所有@Bean 方法创建的实例都是@RefreshScope 的。

【Q-05】Spring Cloud 中默认情况下对于 Eureka Client 实例的创建是在 EurekaClient 的自动配

置类中通过@Bean方法完成的。但在源码中，这个@Bean方法上同时出现了@RefreshScope、

@ConditionalOnMissionBean，与@Lazy 注解，从这些注解的意义来分析，是否存在矛盾呢？

它们联合使用又是什么意思呢？请谈一下你的看法。

【RA】首先来说，这三个注解的意义都是比较复杂的。

@RefreshScope 注解是 Spring Cloud 中定义的一个注解。其表示的意思是，该@Bean 方

法会以多例的形式生成会自动刷新的 Bean 实例。

@ConditionalOnMissionBean 注解表示的意思是，只有当容器中没有@Bean 要创建的实

例时才会创建新的实例，即这里创建的@Bean 实例是单例的。

@Lazy 注解表示延迟实例化。即在当前配置类被实例化时并不会调用这里的@Bean 方

法去创建实例，而是在代码执行过程中，真正需要这个@Bean 方法的实例时才会创建。

这三个注解的联用不存在矛盾，其要表达的意思是，这个@Bean 会以延迟实例化的形

式创建一个单例的对象，而该对象具有自动刷新功能。

【Q-06】Spring Cloud 中大量地使用了条件注解，其中@ConditionalOnRefreshScope 注解对于

Eureka Client 的创建非常重要。请谈一下你对这个注解的认识。

【RA】首先，关于条件注解，实际是 Spring Boot 中出现的内容，其一般应用于配置类中。

表示只有当该条件满足时才会创建该实例。而您提到的@ConditionalOnRefreshScope 注解，

其实际是 Eureka Client 的自动配置类中的一个内部注解。该注解不同于 Spring Boot 中的一般

性注解的是，其是一个复合条件注解，其复合的条件有三个：

 在当前类路径下具有 RefreshScope 类 

 在容器中要具有 RefreshAutoConfiguration 类的实例

 指定的 eureka.client.refresh.enable 属性值为 true。不过，其缺省值就是 true。这也就是

为什么我们的配置文件默认支持自动更新的原因。

只有当这个复合注解中的三个条件均成立时，@ConditionalOnRefreshScope 注解才满足

条件。此时才有可能会调用创建 Eureka Client 的@Bean 方法。所以，该注解对于 Eureka Client

的创建非常重要。

【Q-07】你刚才已经谈过了对@ConditionalOnRefreshScope 注解的认识，非常不错。不过，

与这个注解相对应的另一个注解@ConditionalOnMissingRefreshScope，你是否了解？若关注

过，谈一下你的认识。（不将面试者问死誓不罢休 

） 

【RA】@ConditionalOnMissingRefreshScope 我也曾了解过（看来这个面试者很厉害 ）。这

个注解就像@ConditionalOnRefreshScope 注解一样，也是一个复合条件注解，其也包含了三

个条件。不同的是，这个注解中的条件是或的关系，只要满足其中一条这个注解就匹配上了。

而@ConditionalOnRefreshScope 注解中的三个条件是与的关系，必须所有条件均满足其才能

匹配上。 开课吧 Reythor 雷课程知识点暨面试题总结

讲师：Reythor 雷 

3

这个或的关系是通过让一个复合条件类继承自一个能够表示或关系的复合条件父类

AnyNestedCondition 实现的。这样的话，这个复合条件类中定义的多个内部条件类中，只要

有一个匹配上，那么这个复合条件类就算匹配上了。

【Q-08】Spring Cloud 中 Eureka Client 的源码中有一个非常重要的类 Applications，其被称为

客户端注册表。请谈一下你对它的认识。

【RA】Applications 类实例中封装了来自于 Eureka Server 的所有注册信息，通常称其为“客

户端注册表”。只所以要强调“客户端”是因为，服务端的注册表不是这样表示的，是一个

Map。

该类中封装着一个非常重要的 Map 集合，key 为微服务名称，而 Value 则为 Application

实例。Application 类中封装了一个 Set 集合，集合元素为“可以提供该微服务的所有主机的

InstanceInfo”。也就是说，Applications 中封装着所有微服务的所有提供者信息。

【Q-09】Eureka 源码中 InstanceInfo 类中具有两个最终修改时间戳，这两个时间戳对于 Eureka

的 Server 端与 Client 端源码的理解都比较重要。这两个时间戳你了解过吗？若了解过，请谈

一下你对它们的认识。

【RA】InstanceInfo 实例中封装着一个 Eureka Client 的所有信息，其就可以代表了一个 Eureka 

Client。其封装的两个最终修改时间戳分别为 lastDirtyTimestamp 与 lastUpdatedTimestamp。

这两个时间戳的区别是：

 lastDirtyTimestamp：记录 intance 在 Client 被修改的时间。该修改会被传递到 Server 端。

 lastUpdatedTimestamp：记录 intance 状态在 Server 端被修改的时间。

【Q-10】Eureka 源码中 InstanceInfo 类中具有两个状态属性，是哪两个，你了解过它们吗？

【RA】Eureka 源码中 InstanceInfo 类具有两个状态属性，分别是 status 与 overriddenStatus。

下面我依次谈一下我对它们的了解。

status 就是当前 Instance 的工作状态，其初值为 UP，表示可以正常提供服务。

overriddenStatus 用于记录外部对当前 instance 修改的状态，初值为 UNKNOWN。这个状

态仅在 Server 端是有意义的。其意义就是通过修改 Server 端 instanceInfo 的 overriddenStatus

的值来达到修改 Server 端对应 instanceInfo 的 status 的值的目的。

若要深入了解 overriddenStatus 的意义，就需要了解其被修改的过程。当用户通过

Actuator 的 service-registry 监控终端向某个 Client 提交 POST 状态修改请求后，该请求会被

Client 接收并直接再以 PUT 请求的方式提交给 Server。Server 在接收到这个请求后，会从注

册表中找到该 Client 对应的 InstanceInfo，修改其 overriddenStatus，、status 为指定状态。注

意，用户请求提交到 Client 后，Client 并未修改当前 Client 的 InstanceInfo 的任何状态。即 Client

端的该 InstanceInfo 的状态一直为 UP 状态。

那么这个 overriddenStatus 有什么用呢？当 Server 端注册表中某 instanceInfo 的 status

为 UP 时，其是可以被其它 instance 服务发现的。相反，若其 status 为非 UP，其它 instance

是无法发现和使用该 instance 提供的服务的。Server 端 InstanceInfo 的 status 是可以通过用

户提交状态修改请求修改 overriddenStatus 而达到修改 status 的目的的。

例如，一旦将某 InstanceInfo 的 overriddenStatus 修改为了 OUT_OF_SERVICE，则其 Server

端的 status 也就成了 OUT_OF_SERVICE，此时 Consumer 是无法调用到该 InstanceInfo 对应的

Provider 的服务的。不过需要注意，若直接从浏览器访问该 Provider，其是可以正常给出响

应结果的，并且，此时查看 Provider 中的 InstanceInfo 的 status，仍为 UP。 开课吧 Reythor 雷课程知识点暨面试题总结

讲师：Reythor 雷 

4 

【Q-11】Spring Cloud 中 Eureka Client 与 Eureka Server 的通信，及 Eureka Server 间的通信是

如何实现的？请简单介绍一下。

【RA】Spring Cloud 中 Eureka Client 与 Eureka Server 的通信，及 Eureka Server 间的通信，均

采用的是 Jersey 框架。

Jersey 框架是一个开源的 RESTful 框架，实现了 JAX-RS 规范。该框架的作用与 SpringMVC

是相同的，其也是用户提交 URI 后，在处理器中进行路由匹配，路由到指定的后台业务。这

个路由功能同样也是通过处理器完成的，只不过这里的处理器不叫Controller，而叫Resource。 

**第** **2** **次直播课**

【Q-01】Spring Cloud 中 Eureka Client 在启动时需要从 Eureka Server 中下载注册表到本地进

行缓存，以备进行负载均衡调用。请谈一下你对这个启动时下载注册表过程的认识。

【RA】Spring Cloud 中 Eureka Client 在启动时需要从 Eureka Server 中下载注册表到本地进行

缓存。这次下载属于全量下载，即要将 Server 端所有注册信息 Applicaitons 全部下载到本地

并缓存。当然，若指定可以从远程 Region 获取，其也会通过其所连接的这个 Server，将远

程 Region 中的注册信息也全部获取到。这个过程称为获取客户端注册表。

获取“客户端注册表”最终执行的操作是，通过 Jersey 框架提交了一个 GET 请求，然

后获取到的 Applications 实例结果。

若获取失败，其会从本地备用注册表中获取并缓存。

【Q-02】Spring Cloud 中 Eureka Client 需要定时从 Eureka Server 中获取注册表信息，这个过

程称为服务发现。请谈一下你对这个获取过程的认识。

【RA】Eureka Client 从 Eureka Server 中获取注册表分为两种情况，一种是将 Server 中所有注

册信息全部下载到当前客户端本地并进行缓存，这种称为全量获取；一种是仅获取在 Server

中发生变更的注册信息到本地，然后根据变更修改本地缓存中的注册信息，这种称为增量获

取。当 Client 在启动时第一次下载就属于全量获取，而后期每 30 秒从 Server 下载一次的定

时下载属于增量下载。无论是哪种情况，Client 都是通过 Jersey 框架向 Server 发送了一个

GET 请求。只不过是，不同的获取方式，提交请求时携带的参数是不同的。

【Q-03】Spring Cloud 中 Eureka Client 需要注册到 Eureka Server 中，请谈一下你对这个注册

过程的认识。

【RA】Eureka Client向Eureka Server提交的注册请求，实际是通过Jersey框架完成的一次POST

提交，将当前 Client 的封装对象 intanceInfo 提交到 Server 端，写入到 Server 端的注册表中。

但这个注册请求在默认情况下并不是在Client启动时直接提交的，而是在Client向Server

发送续约信息时，由于其未在 Server 中注册，所以 Server 会中其返回 404，在这种情况下，

而引发的 Client 注册。当然，若 Client 的续约信息发生了变更 Client 也会提交注册请求。 

【Q-04】Spring Cloud 中 Eureka Client 需要定时从 Eureka Server 中更新注册信息。对于这个

定时器及其执行过程，请谈一下你的看法。

【RA】Spring Cloud 中 Eureka Client 需要定时从 Eureka Server 中更新注册信息。但这里是使

用了 one-shot action 的一次性定时器实现的 repeated 定时执行。这个 repeated 过程是通过

其一次性的定时任务实现的：当这个一次性定时任务执行完毕后，会调用启动下一次的定时

任务。 开课吧 Reythor 雷课程知识点暨面试题总结

讲师：Reythor 雷 

5 

【Q-05】Spring Cloud 中 Eureka Client 需要定时从 Eureka Server 中更新注册信息。这个定时

任务是通过一个 one-shot action 的定时器完成的。其为什么不直接使用一个 repeated 的定

时器呢？请谈一下你的看法。

【RA】Spring Cloud 中 Eureka Client 需要定时从 Eureka Server 中更新注册信息。这个定时任

务是通过一个 one-shot action 的定时器完成的。只所以选择 one-shot action 的定时器来完成

一个 repeated 的事情，其主要目的就是方便控制 delay，保证任务顺利完成。

定时器要执行的任务是通过网络从 Server 下载注册信息。而我们知道，网络传输存在

不稳定性，不同的传输数据可能走的网络链路是不同的，而不同的链路的传输时间可能也是

不同的。本次传输超时，下次重试可能走的链路不同就不超时了。

repeated 定时器的执行原理是，本次任务的开始，必须在上一次的任务完成后，不存在

超时。即只要没完成就不会通过执行下次任务进行重试。

使用 one-shot action 定时器完成 repeated 定时任务时，若本次定时任务出现了超时，

则可以在下次任务执行之前增大定时器的 delay。当然，若下载速率都很快，也可将已经增

大的 delay 再进行减小。方便控制 delay，保证任务的顺利完成。

【Q-06】Futue 是 JDK5 中提供的一个接口。其方法 cancel()是一个经常被用到的方法，请谈

一下你对这个方法的认识。

【RA】Futue 是 JDK5 中提供的一个 JUC 的接口，其用于执行一些异步任务。对于其执行的

异步任务，可以通过 cancel()方法尝试着进行取消。其用法为：

 若任务已经完成或已经取消，则本次取消失败。

 若任务在启动之前就调用了 cancel()，则这个任务将不会再执行。

 若任务已经启动，此时再执行 cancel()，那么这个执行的任务是否立即被中断，取决于

cancel()方法的参数。若参数为 true，则会立即中断任务的执行；若参数为 false，则会

让正在执行中的任务执行完毕，然后再中断。

 若cancel()方法执行完毕后，顺序执行isDone()或isCancelled()方法，这些方法均返回true。 

【Q-07】Futue 是 JDK5 中提供的一个接口。其方法 get()是一个经常被用到的方法，请谈一

下你对这个方法的认识。

【RA】Futue 是 JDK5 中提供的一个 JUC 的接口，其用于执行一些异步任务，并通过 get()方

法可以获得该异步任务的结果。get()方法是一个阻塞的方法，可以为其指定阻塞的最长时长。

 若在指定时长内异步操作完成，则阻塞会被立即唤醒；

 若在指定时长内该异步操作被 cancel()，则阻塞也会被立即唤醒，并抛出一个

CancellationException； 

 若在指定时长内未发生任务事情，则阻塞也会被唤醒，并抛出一个 TimeoutException； 

 若 get()方法没有指定阻塞时长，则其会一直阻塞下去，直到任务完成或取消。

【Q-08】Spring Cloud 中 Eureka Client 向 Eureka Server 发送增量获取注册表请求，Server 会

返回给 Client 一个 delta，关于这个返回值 delta，请谈一下你的看法。

【RA】Spring Cloud 中 Eureka Client 向 Eureka Server 发送增量获取注册表请求，Server 会返

回给 Client 一个 delta，这个 delta 是一个 Applications 类型的变量。

 Server 返回的这个 delta 值若为 null，则表示 Server 端基于安全考虑，禁止增量下载，

其会自动进行全量下载。

 Server 返回的这个 delta 值不为 null，但其包含的 application 数量为 0，则表示没有更新

内容。若数量大于 0，则表示有更新内容。有更新内容，则需要将更新添加到本地缓存 开课吧 Reythor 雷课程知识点暨面试题总结

讲师：Reythor 雷 

6

的注册表 applications 中。

【Q-09】Spring Cloud 中 Eureka Client 向 Eureka Server 发送增量获取注册表请求，Server 端

是如何知道哪些 intance 对这个 Client 来说是变更过的？请谈一下你的看法。

【RA】当 Eureka Server 接收到 Eureka Client 发送的增量获取注册表请求后，其并不知道哪些

instance 对于这个 Client 来说是更新过的。但是在 Server 中维护着一个“最近变更队列”，

无论对于哪个 Client 的增量请求，Server 端都是将该队列中的 instance 变更信息发送给了

Client。当然，Server 中有一个定时任务，当这个 instance 的变更信息不再属于“最近”时，

会将该 instance 变更信息从队列中清除。

当 Client 接收到 Server 发送的增量变更信息后，Client 端有一种判断机制，可以判断出

其接收到这个增量信息对它自己来说是否出现了更新丢失。即出现了队列中清除掉的变更信

息，并没有更新到当前 Client 本地。若发生更新丢失，Client 会再发起全量获取，以保证 Client

获取到的注册表是最完整的注册表。

【Q-10】Spring Cloud中Eureka Client从Eureka Server中增量获取到的注册信息，都是在Server

端发生了变更的 instanceInfo 信息。这些变更信息中包含变更的类型。其中对于 ADDED 与

MODIFIED 这两种类型的变更，我们发现处理方式是相同的，为什么？请谈一下你的看法。

【RA】Eureka Client 接收到的来自 Server 的增量注册信息后，对于添加变更与修改变更的处

理方式的确是相同的，都是采用了添加变更的处理方式。其实，无论是添加的 InstanceInfo

还是修改的 InstanceInfo，Client 首先都是根据该 InstanceInfo 的 id，从本地 InstanceInfo 的 Set

集合中将其删除，然后再将新来的变更的 InstanceInfo 加入 Set 集合。只不过，对于添加变

更，其在原来的 Set 集合中找不到其要删除的 InstanceInfo 而已。

只所以能够被根据 InstanceId 在 Set 集合中进行删除，是因为 Set 集合的元素 InstanceInfo

重写了 equals()方法——根据 instanceId 进行元素相等判断。

【Q-11】Spring Cloud 中 Eureka Client 会向 Eureka Server 进行定时续约，请谈一下你对这个

定时续约的认识。

【RA】Eureka Client 会向 Eureka Server 进行定时续约，即会进行定时心跳。其最终就是通过

Jersey 框架向 Eureka Server 提交一个 PUT 请求。该 PUT 请求没有携带任何请求体，而 Eureka 

Server 仅仅就是接收到一个 PUT 请求。但通过请求，Server 能够知道这个请求的发送者

instanceId。而 Eureka Server 就是通过这个发送者 instanceId 从注册表中查找其 instance 信息

的。当然，Server 也给 Client 发送来了响应信息：若从 Server 的注册表中找到了该续约的

instance，则返回该 instanceInfo 实例；若没有找到，则返回 404。 

**第** **3** **次直播课**

【Q-01】Spring Cloud 中 Eureka Client 会定时检测 Client 的 instanceInfo 是否发生了变更。请

谈一下你对这个定时任务的认识。

【RA】Eureka Client 会定时检测 Client 的 instanceInfo 是否发生了变更，其主要是检测了两样

内容：一个是检测数据中心中的关于当前 instanceInfo 的信息是否变更，一个是检测配置文

件中当前 instanceInfo 中的续约信息是否变更。只要发生了变更，则将变化后的信息发送给

Server，这个发送执行的是 register()注册。 开课吧 Reythor 雷课程知识点暨面试题总结

讲师：Reythor 雷 

7 

【Q-02】Spring Cloud 中 Eureka Client 向 Eureka Server 提交 registrer()注册请求的时机较多，

请简单总结一下。

【RA】Eureka Client 向 Eureka Server 提交的 register()注册请求的情况有三种：

 在 Client 实例初始化时直接提交 register()注册请求

 定时发送心跳时，服务端返回 404，此时 Client 会发出 registrer()注册请求

 定时更新 Client 续约信息给 Server 时，只要 Client 续约信息发生变更，其提交的就是

register()注册请求

【Q-03】Spring Cloud 中 Eureka Client 在做定时更新续约信息给 Server 时有一个定时任务，

定时查看本地配置文件中的 instanceInfo 是否发生了变更。这个定时任务在 Eureka Client 启

动时通过 start()启动了定时任务，该定时器是一个 one-shot action 定时器，其会调用

InstanceInfoReplicator 的 run()方法。而该方法会再次启动一个 one-shot action 的定时任务，

实现了 repeated 定时执行。然而，当 instanceInfo 的状态发生变更后会调用一个按需更新方

法 onDemandUpdate()，该方法同样会调用 InstanceInfoReplicator 的 run()方法，再次启动一

个 one-shot action 的定时任务，实现了 repeated 定时执行。这样的话，只要发生一次状态

变更，就会启动一个 repeated 的定时任务持续执行下去。那么若 InstanceInfo 的状态多次发

生变更，是否就会启动很多的一直持续执行的该定时任务了？请谈一下你的看法。

【RA】答案当然是否定的。关键就在于两点：一个是，前面题目中无论是 start()方法还是

InstanceInfoReplicator 的 run()方法，在启动了定时任务后，都会将定时任务实例 future 写入

到一个原子引用类型的缓存中，且后放入的会将先放入的覆盖，即这个缓存中存放的始终为

最后一个定时任务。第二个关键点是 这 个 onDemandUpdate() 方法。其在调用

InstanceInfoReplicator 的 run()方法之前首先将这个缓存中的异步操作 cancel()，即将最后一个

定时任务结束，然后才会再启动一个新的定时任务。所以，只会同时存在一个该定时任务。

【Q-04】Spring Cloud 中 Eureka Client 的续约配置信息默认情况下是允许动态变更的。为了

限制变更的频率，Eureka Client 使用了一种限流策略，是什么策略？请谈一下你对这种策略

的认识。

【RA】Spring Cloud 中 Eureka Client 的续约配置信息默认情况下是允许动态变更的。为了限

制变更的频率，Eureka Client 使用了令牌桶算法。

该算法实现中维护着一个队列，首先所有元素需要进入到队列中，当队列满时，未进入

到队列的元素将丢弃。进入到队列中的元素是否可以被处理，需要看其是否能够从令牌桶中

拿到令牌。一个元素从令牌桶中拿到一个令牌，那么令牌桶中的令牌数量就会减一。若元素

生成速率较快，则其从令牌桶中获取到令牌的速率就会较大。一旦令牌桶中没有了令牌，则

队列很快就会变满，那么再来的元素将被丢弃。

【Q-05】Spring Cloud 中 Eureka Client 的哪些操作会引发客户端 InstanceInfo 的最新修改时间

戳 lastDirtyTimestamp 的变化？请谈一下你的认识。

【RA】Spring Cloud 中 Eureka Client 的操作中有两处操作可以引发客户端 InstanceInfo 的最新

修改时间戳 lastDirtyTimestamp 的变化。

 在进行第一次心跳发送时，由于 Server 中没有发现该 InstanceInfo 而向其返回了 404。

此时的 Client 会修改 lastDirtyTimestamp 的值。

 在续约信息发生更新时修改 lastDirtyTimestamp 的值。

【Q-06】Spring Cloud 中 Eureka Client 通过 Actuator 提交的 POST 请求的 shutdown 进行服务 开课吧 Reythor 雷课程知识点暨面试题总结

讲师：Reythor 雷 

8

下架时，其调用的下架处理方法我们从哪里找到它？请谈一下你的思路。

【RA】Spring Cloud 中 Eureka Client 通过 Actuator 提交的 POST 请求的 shutdown 进行服务下

架，就是要销毁 Eureka Client 实例。而该 Eureka Client 实例是在 EurekaClient 的自动配置类

中通过@Bean 方法创建的。所以，这个下架处理方法应该是@Bean 注解的 destroyMethod

属性指定的方法。

【Q-07】Spring Cloud 中 Eureka Client 通过 Actuator 提交的 POST 请求的 shutdown 进行服务

下架时，其 Client 内部都做了些什么重要工作？请谈一下你对这个服务下架的认识。

【RA】Eureka Client 通过 Actuator 提交的 POST 请求的 shutdown 进行服务下架时，其内部主

要完成了四样工作：

 将状态变更监听器删除

 停止了一堆定时任务的执行，并关闭了定时器

 通过 Jersey 框架向 Eureka Server 提交了一个 DELETE 请求

 关闭了一些其它相关工作

【Q-08】对于 Spring Cloud 中的 Eureka，用户通过平滑上下线方式进行 Client 状态的修改。

这个状态修改请求是被客户端的哪个类处理的，这个类实例是在何时创建的？请谈一下你的

认识。

【RA】对于 Spring Cloud 中的 Eureka，用户通过平滑上下线方式进行 Client 状态的修改。这

个状态修改请求是被客户端的 ServiceRegistryEndpoint 类实例的 setStatus()方法处理的。这个

类实例是在 Spring Cloud 应用启动时被加载创建的。具体来说，spring-cloud-starter 依赖于

spring-cloud-common，而该 common 依赖加载并实例化了 ServiceRegistryAutoConfigration 配

置类。在该配置类中实例化了 ServiceRegistryEndpoint 类。

【Q-09】对于 Spring Cloud 中的 Eureka，用户通过 Actuator 的 service-registry 监控终端提交

状态修改请求，请谈一下你对这个请求处理过程的认识。

【RA】对于 Spring Cloud 中的 Eureka，用户通过 Actuator 的 service-registry 监控终端提交状

态修改请求，服务平滑上下线就属于这种情况，但这种情况不仅限于服务平滑上下线。

当 Client 提交的状态为 UP 或 OUT_OF_SERVICE 时，属于平滑上下线场景。该请求会被

Client 接收并直接再以 PUT 请求的方式提交给 Server，在 Client 端并未修改 Client 的任何状

态。Server 在接收到这个请求后，会从注册表中找到该 Client 对应的 InstanceInfo，修改其

overriddenStatus、status 为指定状态。

当 Client 提交的状态为 CANCEL_OVERRIDE 时，是要将 Server 端当前 Client 对应

InstanceInfo 的 overriddenStatus 从一个缓存 map 中删除，并将其 overriddenStatus 与 status

修改为 UNKNOWN 状态。这个缓存 map 中记录着注册到当前 Server 中的每一个 instanceInfo

对应的 overriddenStatus，这个 map 中的状态值对于其它 Client 发现一个 InstanceInfo 的对外

表现状态 status 非常重要。当服务端的某 InstanceInfo 的 overriddenStatus 变为 UNKNOWN

时，该 Client 发送的心跳 Server 是不接收的。Server 会向该 Client 返回 404。 

【Q-10】对于 Spring Cloud 中的 Eureka，用户通过 Actuator 的 service-registry 监控终端提交

状态修改请求，如果用户提交的状态是一个非法状态会怎么样？请谈一下你的认识。

【RA】对于 Spring Cloud 中的 Eureka，用户通过 Actuator 的 service-registry 监控终端提交状

态修改请求，这个状态值一般为五个标准状态 UP、DOWN、OUT_OF_SERVICE、STARTING、

UNKNOWN 中的 UP 或 OUT_OF_SERVICE，也可以是 CANCEL_OVERRIDE。但若用户提交的不 开课吧 Reythor 雷课程知识点暨面试题总结

讲师：Reythor 雷 

9

是这六种情况之一，系统会将其最终归结为 UNKNOWN 状态。

【Q-11】Spring Cloud 中 EurekaServerAutoConfiguration 自动配置类被实例化的一个前提条件

是，容器中要有一个 Marker 实例，这个 Marker 实例是在哪被添加到了容器？

【RA】Spring Cloud 中关于 Eureka Server 的这个 Marker 实例，就是 Eureka Server 的一个标

识，一个开关。该实例被添加到了容器，Eureka Server 就开启了。其是在 Eureke Server 启动

类上的@EnableEurekaServer 注解中被实例化并添加到的容器。所以，若没有添加该注解，

Eureka Server 启动类的启动是不会创建启动 Eureka Server 的。

【Q-12】Spring Cloud 中 Eureka Client 会注册到 Eureka Server 的注册表中，在 Server 中这个

注册表是以怎样的形式存在的？当Eureka Client将Eureke Server中的注册信息下载到本地后，

这个注册表又是以怎样的形式存在的？请谈一下你的认识。

【RA】Spring Cloud 的 Eureka Server 中的这个注册表是一个双层 Map，外层 map 的 key 为微

服务名称，value 为内层 map。内层 map 的 key 为 instanceId，value 为 Lease 对象。Lease 对

象中包含一个执有者 Holder 属性，表示该 Lease 对象所属的 InstanceInfo。 

当 Eureka Client 将 Server 端的注册表下载到了本地，该注册表是以 Applications 形式出

现的。Applications 中维护着一上 Map 集合，key 为微服务名称，value 为 Application 实例。

该 Application 实例中包含了所有提供该微服务名称的 InstanceInfo 信息。因为 Application 中

也维护着一个 Map，key 为 instanceId，value 为 InstanceInfo。 

【Q-13】Eureka Client 提交的状态修改请求，Eureka Server 是如何处理的，Server 端都做了

哪些变更？请谈一下你的认识。

【RA】Eureka Client 提交的状态修改请求，Eureka Server 在接收到后，首先根据该 Client 的

微服务名称及 instanceId 在 Server 端注册表中进行了查找。若没有找到，则直接返回 404；

若找到了，其会执行两大任务：

 任务一：将客户端修改请求中的新状态写入到注册表中。

 任务二：将写入到当前 server 注册表中新的状态同步到其它 server。

而在第一项任务中完成的重要工作有如下几项：

 使用新状态替换缓存 overriddenInstanceStatusMap 中的老状态

 修改 instanceInfo 的 overriddenStatus 状态为新状态

 修改 instanceInfo 的 status 状态为新状态

 更新来自于请求参数的客户端修改时间戳 lastDirtyTimestamp

 将本次修改形为记录到 instanceInfo 的行为类型中

 修改服务端修改时间戳 lastUpdatedTimestamp

 将本次修改记录到最近更新队列 recentlyChanngeQueue 中 

【Q-14】Eureka Server 中的注册表发生了变更，其是怎样将变更同步到其它 Server 的？请谈

一下你的看法。

【RA】Eureka Server 中的注册表发生了变更，并不是一定要同步给其它 Server 的，需要分

情况处理。

若这个变更是由 Client 端直接引发，则当前 Server 会遍历所有其它 Server，通过 Jersey

框架向每一个其它 Server 发送变更请求。这样就实现了同步。

若这个变更是由其它 Server 端发送的变更，则其仅仅会在本地变更一下即可，不会再 开课吧 Reythor 雷课程知识点暨面试题总结

讲师：Reythor 雷

10

向其它 Server 发送变更请求，以防止出现无限递归。

**第** **4** **次直播课**

【Q-01】Eureka Client 提交的 CANCEL_OVERRIDE 状态修改请求，Eureka Server 是如何处理的，

Server 端都做了哪些变更？请谈一下你的认识。

【RA】Eureka Client 提交的 CANCEL_OVERRIDE 状态修改请求，Eureka Server 在接收到后，首

先根据该 Client 的微服务名称及 instanceId 在 Server 端注册表中进行了查找。若没有找到，

则直接返回 404；若找到了，其会执行两大任务：

 任务一：将 Server 端删除 overridden 状态。

 任务二：将此变更同步到其它 server。

删除 overridden 状态，从哪里删除呢？这个删除处理，在 Server 端主要完成了三样工

作：

 将该 instanceInfo 在缓存集合 overriddenInstanceStatusMap 中的 Entry 删除。

 将 instanceInfo 中的 overridden 状态变更为 UNKNOWN。 

 将 instanceInfo 中的 status 状态变更为 UNKNOWN。

overriddenInstanceStatusMap 中的缓存的 instanceInfo的 overridden 状态，对于后续注册、

续约等请求处理时instanceInfo的状态判断起很大作用。另外此时，该Client发送的心跳Server

是不接收的。Server 会向该 Client 返回 404。 

【Q-02】Eureka Client 的注册请求被 Server 接收到后，会首先判断该 Client 在注册表中是否

存在。按理说，这里是注册处理，注册表中应该是不存在该 Client 的 lease 信息的，但的确

会出现新注册的 Client 在注册表中存在的情况，这是为什么？请谈一下你的看法。

【RA】Eureka Client 的注册请求被 Server 接收到后，注册表中可能会出现新注册的 Client 在

注册表中已经存在的情况。这是因为，当 Client 的 instanceInfo 的续约信息发生了变更，Client

的“定时更新 InstanceInfo 信息给 Server”的定时任务发出的是 register()请求，但该客户端

其实在之前已经注册过了。此时就会出现注册表中已经存在该 instanceId 的情况。

【Q-03】Eureka Server 在处理新注册的 Client 在注册表中已经存在的情况时会出现一种比较

奇怪的情况：当前新注册的 InstanceInfo 中的 lastDirtyTimestamp，比注册表中缓存的当前这

个 InstanceInfo 中的 lastDirtyTimestamp 小。即后注册的反而过时，这是为什么？请谈一下你

的看法。

【RA】ureka Server 在处理新注册的 Client 在注册表中已经存在的情况时会出现，当前新注

册的 InstanceInfo 中的 lastDirtyTimestamp，比注册表中缓存的当前这个 InstanceInfo 中的

lastDirtyTimestamp 小的情况，即后注册的反而过时。这是因为，若 Client 的 instanceInfo 的

续约信息相继发生了两次变更，Client 就提交了两次 register()请求。但是由于网络原因，第

二次注册请求先到达 Server。当第一次注册请求到达后就会出现“后到达的注册请求中携带

的 instanceInfo 的最后修改时间反而过时”的情况。

【Q-04】Eureka Server 在处理 Client 的注册时请求时，是否可能出现新注册的 registrant 的

OverriddenStatus 状态不是 UNKNOWN 的场景呢？为什么？请谈一下你的看法。 开课吧 Reythor 雷课程知识点暨面试题总结

讲师：Reythor 雷

11

【RA】这种场景是可能会出现的。且只有一种情况：当前注册的 registrant 是由于其续约信

息发生了变更而引发的注册，且在续约信息变更之前用户通过 Actuator 修改过状态。

当然，这种通过 Actuator 修改的状态仅仅修改的是 Server 端注册表中的状态，并没有

修改客户端的任何状态。这个修改的结果实际是通过客户端定时更新客户端注册表时，将所

有变更信息下载到的客户端，其中就包含它自己状态的修改信息。

【Q-05】Eureka Server 会根据 Client 请求中携带的状态信息、该 Client 在 Server 的注册表的

InstanceInfo 中的状态信息，及缓存 map 中的 OverriddenStatus 状态信息根据指定规则计算

出当前 Client 的 status。请问，Eureka Server 中使用的是哪种状态计算规则？请谈一下你对

这个规则的认识。

【RA】Eureka Server 中使用的状态计算规则为 FirstMatchWinsCompositeRule。该规则是一个

复合规则，具有一个包含了三条子规则的有序列表：DownOrStartingRule、OverrideExistsRule

与 LeaseExistsRule。其会依次逐个尝试着去匹配其所包含的子规则，并返回第一个匹配上的

结果。若都没有匹配上，则返回 AlwaysMatchInstanceStatusRule 规则的结果。这个规则能够

匹配上任意 InstanceInfo 的状态。

【Q-06】请谈一下你对 Eureka Server 中的 DownOrStartingRule 状态匹配规则的认识。 

【RA】DownOrStartingRule 是计算 instanceInfo 状态的一种规则，该规则的执行原则是：只

要参数的 instance 的 status 是 STARTING 或 DOWN 状态，那么这个状态是可信的，即可以直

接将这个状态值作为计算出的 intance 的真正服务状态结果返回。若是参数的 instance 的服

务状态为 UP 或 OUT_OF_SERVICE 状态，那么，这个状态是不可靠的。因为该 instance 在服

务端的状态可能已经被 Actuator 给改了。所以需要再查看该 instance 的状态是否在服务端也

被修改了。所以这个状态是不可靠的，需要对其进行再次确认。所以返回“不匹配”的结果，

以进行下一个规则的匹配。从代码可以看出，只有 UP 与 OUT_OF_SERVICE 状态是匹配不上

这个规则的。也就是说，能进入下一个规则判断，一定是 UP 或 OUT_OF_SERVICE 状态。

【Q-07】请谈一下你对 Eureka Server 中的 OverrideExistsRule 状态匹配规则的认识。 

【RA】OverrideExistsRule 是计算 instanceInfo 状态的一种规则。在进行该规则之前是先进行

了 DownOrStartingRule 规则匹配的，所以能走到这里，说明参数的 intance 的服务状态是 UP

或 OUT_OF_SERVICE。该规则的执行原则是：查看服务端缓存 overriddenInstanceStatusMap

中是否有其对应的可覆盖状态 overriddenStatus。若有，则直接将这个状态作为计算结果返

回。若没有，则该规则未被匹配上。进入下一个规则进行匹配。

【Q-08】请谈一下你对 Eureka Server 中的 LeaseExistsRule 状态匹配规则的认识。 

【RA】LeaseExistsRule 是计算 instanceInfo 状态的一种规则。在进行该规则之前是先进行

了 OverrideExistsRule 规则匹配的，所以能走到这里，说明参数的 intance 的服务状态是 UP

或 OUT_OF_SERVICE。该规则的执行原则是：查看服务端注册表中该 instance 对应的服务状

态是否也是 UP 或 OUT_OF_SERVICE。若是，则直接将这个状态作为计算出的 intance 的真正

服务状态结果返回。若注册表中没有对应的 instance，或注册表中对应 instance 的状态不是

OUT_OF_SERVICE 与 UP，则返回“不匹配”结果，以进行下一个规则的匹配。

【Q-09】请谈一下你对 Eureka Server 中的 AlwaysMatchInstanceStatusRule 状态匹配规则的认

识。

【RA】AlwaysMatchInstanceStatusRule 是计算 instanceInfo 状态的一种规则。首先，从这个类 开课吧 Reythor 雷课程知识点暨面试题总结

讲师：Reythor 雷

12

名可以看出，该规则可以匹配上任意状态，最终都会给出一个当前 instance 服务状态的计算

结果的。只所以可以匹配任意状态，是因为其是直接返回参数给的的 instance 的 status 状态，

无论是什么状态。

**第** **5** **次直播课**

【Q-01】Eureka Client 提交的续约请求，Eureka Server 是如何处理的？请谈一下你的认识。

【RA】客户端续约请求，即客户端向服务端发送心跳。客户端的心跳提交的是一个没有携

带任何请求体的 PUT 请求，不过其在请求 URI 中携带了心跳的发出者的 InstanceId，及当前

心跳发出者的状态。Server 端对于续约请求，主要完成了两若项任务：

 当 Server 接收到 Client 发送的续约信息后，根据注册表中当前 InstanceInfo 的状态信息

计算出其状态，然后更新为新的 status。 

 将心跳同步到其它 server。 

 在 Server 间的同步过程可能会导致 Server 间 overridden 状态的不一致。所以又进行了

该状态的统一。

【Q-02】Eureka Server间进行续约同步过程中可能会导致overridden状态的不一致，为什么？

请谈一下你的看法。

【RA】首先要清楚一点，Eureka 是 AP 的，是允许出现 Server 间数据不一致的。例如，当前

Eureka 中由于客户端下架请求而从注册表中删除了某 Client，在进行 Server 间同步时，由于

另一个 Server 处于自我保护模式，所以其是不能删除 Client 的。此时就出现了 Server 间数据

的不一致。

下面再来说续约。无论是直接处理Client的续约请求，还是处理Server间续约同步，Server

端对于续约的处理，根本不涉及 lastDirtyTimestamp 时间戳，及 overridden 状态。这一点从

续约的源码中是可以看出来的。那么有可能会出现以下场景：Client 通过 Actuator 修改了状

态，而这个状态修改操作在 Server 间同步时并没有同步成功，出现了 Server 间对于同一个

InstanceInfo 中 overridden 状态的不一致。

虽然 Eureka 本身是 AP 的，但其仍是尽量想让 Eureka 间实现同步，所以在其发生最频

繁的续约中解决了这个问题。只不过，由于续约本身根本不涉及 overridden 状态，仅靠续约

是解决不了的。所以需要在 Eureka Server 的配置文件中添加专门的配置解决这个问题。不

过，这个属性设置默认是开启的。

【Q-03】Eureka Server 在进行续约处理时，若发现其计算的当前 isntanceInfo 的 status 状态

为 UNKNOWN，说明什么？请谈一下你的看法。

【RA】Eureka Server 在进行续约处理时，若发现其计算的当前 instanceInfo 的 status 状态为

UNKNOWN，说明这个计算结果是在 OverrideExistsRule 规则中计算出的结果，即当前

instanceInfo 的 overridden 状态为 UNKNOWN。对于一个 InstanceInfo 来说，可以从缓存 map

中读取到其 overridden 状态为 UNKNOWN，只能有一种情况：这个 UNKNOWN 的 overridden

状态是通过 Actuator 的 CANCEL_OVERRIDE 修改的状态，即用户取消了该 InstanceInfo 的

overridden 状态。

那么也就是说，Eureka Server 在进行续约处理时，若发现其计算的当前 instanceInfo 的

status 状态为 UNKNOWN，则说明该 InstanceInfo 已经不对外提供服务了。 开课吧 Reythor 雷课程知识点暨面试题总结

讲师：Reythor 雷

13

【Q-04】Eureka Client 提交的下架请求，Eureka Server 是如何处理的？请谈一下你的认识。

【RA】Eureka Server 在接收到 Client 的下架请求后，主要完成了两项任务：

 从注册表中将该提交请求的 intanceInfo 删除，并将其 overridden 状态从缓存 map 中删

除，记录的删除时间戳，最后修改时间戳 lastUpdatedTimestamp 等。

 将下架请求同步到其它 server。 

【Q-05】Eureka Server 在处理 Client 的全量下载注册信息请求时可以设置从自己的只读缓存

readOnlyCacheMap 中获取到所有注册到自己的注册信息，而 readOnlyCacheMap 中的数据是

定时同步的读写缓存 readWriteCacheMap 的。这样的话就存在一个问题：这个定时更新无论

更新频率多么高，一定存在用户从 readOnlyCacheMap 中读取的数据与 readWriteCacheMap

中不一致的情况，为什么不直接从 readWriteCacheMap 中读取？也就是说，这样的设计好处

是什么？请谈一下你的认识。

【RA】这样设计的目的是为了保证在并发环境下“集合迭代的稳定性”。集合迭代的稳定性

指的是，当一个共享变量是集合且存在并发读写操作时，要保证在对共享集合进行读操作时

能够读取到稳定的数据，即在读取时不能对其执行写操作，但又不能妨碍了写操作的执行。

此时就可以将集合的读写功能进行分离，创建出两个共享集合：一个专门用于处理写功能，

外来的数据写入到这个集合；一个专门用于处理读功能，定时同步写集合的数据。这种方案

存在的弊端是，无法保证只读集合中的数据与读写集合中数据的随时完全一致。当然，这种

不一致在下一次定时同步时就会达到一致。所以这种方案的应用场景是对数据的实时性要求

不是很高的情况。

【Q-06】Eureka Server 在处理 Client 的全量下载注册信息请求与处理增量下载请求有什么不

同？请谈一下你的认识。

【RA】Eureka Server 在处理 Client 的全量下载注册信息请求时，其读取的是当前 Server 注册

表 registry 中的注册信息，而处理增量下载请求时根本就没有操作注册表 registry，而是直接

读取了最近更新队列 recentlyChangeQueue 中的信息。这两种请求的处理方式，操作了两上

不同的共享集合。

【Q-07】Eureka Server 在处理 Client 的增量下载注册信息请求时是从 recentlyChangeQueue

最近更新队列中直接获取的数据，这个 recently 是多久？如果超过了这个 recently 时间又是

如何处理的？请谈一下你的认识。

【RA】最近更新队列 recentlyChangeQueue 中的 recently 是可能通过配置文件属性指定的，

默认为 3 分钟。当 recentlyChangeQueue 中的元素超过了 3 分钟，那么系统会自动将这些过

期的元素删除。只不过这个删除操作是一个 repeated 定时任务，在 AbstractInstanceRegistry

类的构造器中被创建并启动，默认每 30 秒执行一次。

【Q-08】Eurek Server 对于像 Client 注册、状态修改等写操作添加的都是读锁，而对于像增

量下载请求添加的是写锁，为什么？为什么对于续约请求这种写操作处理中没有添加读锁？

为什么全量下载中没有添加写锁？对于 Eureka Server 中添加锁的方式，请谈一下你的认识。

【RA】总体来说，这种读/写锁的添加方式就是为了解决两个共享集合 recentlyChangedQueue 

与注册表 registry 的“集合迭代稳定性”问题。即增加读锁是为了限制其增加写锁，而增加

写锁也是为了限制其增加读/写锁。若仅是考虑到 recentlyChangedQueue 集合的迭代稳定性

问题，完全可以在处理注册、状态修改、删除 overridden 状态、下架、续约等写操作请求时

添加写锁，而在处理全量下载、增量下载请求时添加读锁。 开课吧 Reythor 雷课程知识点暨面试题总结

讲师：Reythor 雷

14

但这样做对于注册表 registry 集合来说就会出现问题。由于续约请求是一个发生频率非

常高的写操作处理，若为其添加了写锁，则意味着在进行续约处理时，其它任何对 registry

的读/写操作均将阻塞。所以，续约处理是不能加写锁的。那为其添加读锁是否可以呢？也

不行。因为对于这么一个发生频率很高的处理，若添加了读锁，那么，几乎这个 registry 就

会被读锁给锁定，其它任何写操作均将被阻塞。所以，续约处理不能加锁。

处理注册、状态修改、删除 overridden 状态、下架等写操作请求时，为什么要添加读锁

呢？添加写锁不行吗？若添加写锁，则意味着，任意一个对 registry 的写操作请求处理，均

将阻塞所有其它对 registry 的读/写操作，效率非常低。而若这些写操作添加的是共享锁读锁，

则意味着，这些写操作可以同时进行。即使可能会出现对这些写操作同时操作同一个 registry

中的相同 instanceInfo 的情况，也不会出现问题。因为 registry 及 recentlyChangedQueue 都 

是 JUC 的，是线程安全的。

由于那些写操作添加了读锁，所以增量下载这种读操作添加了写锁，以保证对共享集合

读/写操作的互斥。

为什么增量下载添加了写锁，而全量下载没有添加呢？因为增量下载中没有涉及对共享

集合注册表 registry 的操作，而全量下载读取了 registry。若为全量下载添加写锁，则必然会

导致其在读取期间出现续约请求处理被阻塞的情况。对于这种频率非常高的续约处理是不能

停止的。

**第** **6** **次直播课**

【Q-01】Eurek Server 对于续约过期的 Client 会定期进行清除，这个定时任务是何时启动的？

由谁来完成的？又做了些什么？请谈一下你的认识。

【RA】Eurek Server 对于续约过期的 Client 的定时清除任务是在 Eureka Server 启动时专门创

建了一个新的线程来执行的。确切地说，是 EurekaServerAutoConfiguration 在做实例化过程

中完成的该定时任务线程的创建、执行。

这个定时任务首先查看了自我保护模型是否已经开启，若已经开启则不进行清除。若没

有开启，则首先会将所有失联的 instance 集中到一个集合中，然后再计算“为了不启动自我

保护模型，最多只能清除多少个 instance”，在进行清除时不能越过此最大值。

【Q-02】Eurek Server 对于续约过期的 Client 会定期进行清除时有一个“补偿时间”概念。

什么是补偿时间，请谈一下你的认识。

【RA】对于“补偿时间”的理解，首先要清楚 repeated 定时器的执行原理。本次任务的执

行条件有两个，这两个条件必须同时满足才会执行任务。一是，上次任务执行完毕，二是，

按照配置文件中设置的清除间隔，本次任务的执行时间点也已经到了或过了。

那么什么是“补偿时间”呢？举例来说。

例如，正常情况下，若每 5s 清除一次过期对象，而清除一次需要 2s，则在第 5s 时开始

清除 0s-5s 期间的过期对象。第 10s 开始清除 5s-10s 期间的过期对象。

若清除操作需要 6s，则在第 5s 时会开始清除，其清除的是 0s-5s 期间的过期对象。然

而这次清除用时 6s，也就是说，在第 11s 时才清除完毕 0s-5s 期间的过期对象。按理说应该

在第 10s 时开始清除 5s-10s 期间的过期对象，但由于上次的清除任务还未结束，所以在第

10s 时不能开始清除，而在第 11s 时开始清除操作。因为已经过了 10s 这个时间点。此时要

清除的对象就应该是 5s-11s 期间过期的，而多出的那 1s 就是需要补偿的时间。 开课吧 Reythor 雷课程知识点暨面试题总结

讲师：Reythor 雷

15

【Q-03】Eurek Server 对于续约过期的 Client 会定期进行清除，而这个清除过程中，系统会

从过期对象数量 expiredLeases.size，与开启自我保护的阈值数量 evictionLimit 两个数值中选

择一个最小的数进行清除。根据这个最小值进行清除，是不是会导致自我保护模式永远无法

启动的情况？若出现了很多的过期对象，即这个 expiredLeases.size 很大，而 evictionLimit 是

固定的。那么其清除的一定是 evictionLimit 个过期对象。这样的话是否自我保护模型永远无

法启动？

【RA】答案是否定的。自我保护模式的启动并不是由这个清除任务决定的，而是由其它线

程决定。只要发现收到的续约数据低于阈值了，那么就会启动自我保护模式。这里选择最少

的进行清除，是为了尽量少些清除，给那些没有被清除的对象以“改过自新，浪子回头”的

机会。可能由于网络抖动导致的失联，网络现在好了，其还可以恢复。若直接清除掉，那么

就没有这个恢复的机会了。

【Q-04】Spring Cloud 中 OpenFeign 的@EnableFeignClients 与@FeignClient 两个注解有怎样的

区别与联系。请谈一下你的认识。

【RA】@EnableFeignClients 注解主要用于查找所有的@FeignClient 接口，并为这些 Feign Client

设置一些默认的配置。而@FeignClient 则是就某一个特定的 Feign Client 进行配置。一个

Consumer 中只能有一个@EnableFeignClients，但可以有多个@FeignClient。 

【Q-05】Spring Cloud 中 OpenFeign 中@FeignClient 注解中有一个 name 属性与 path 属性。

这两个属性是什么意思？请谈一下你的认识。

【RA】Spring Cloud中OpenFeign中@FeignClient注解中的name属性用于指定当前Feign Client

的名称，这个名称为其要消费的提供者微服务名称。消费者对提供者的负载均衡就是通过这

个名称实现的。而 path 属性用于指定直连方式的连接的提供者的 ip 与 port。一旦指定了 path

属性，就不再使用负载均衡方式来选择提供者了。

【Q-06】Spring Cloud 中 OpenFeign 中有一个 FeignClientSpecification 类，这个类是干嘛的？

请谈一下你的认识。

【RA】FeignClientSpecification 是一个 Feign Client 的生成规范。所谓生成规范就是该实例中

定义了生成 Feign Client 的各种配置信息，在动态生成 Feign Client 时需要按照这些配置信息

来生成。具体的规范存放在 configuration 属性中。

【Q-07】Spring Cloud 中 OpenFeign 中有一个 FeignContext 类，这个类是干嘛的？请谈一下

你的认识。

【RA】FeignContext 是一个为 Feign Client 创建所准备的上下文对象，从这个对象中可以获取

到每一个要创建的 Feign Client 所需要的 Spring 子容器，而在这些子容器中存放着创建每一

个不同的 Feign Client 所需要的“原材料”bean。一个应用只会有一个 FeignContext 实例。

**第** **7** **次直播课**

【Q-01】Spring Cloud 中 OpenFeign 中对于 Feign Client 的创建源码解析，从哪里下手开始呢？

请谈一下你的思路。

【RA】对于 Feign Client 的创建源码解析从@EnableFeignClients 着手分析是比较好的。该注

解中@Import 了一个 FeignClientsRegistrar 类。该类实现了 ImportBeanDefinitionRegistrar 接口， 开课吧 Reythor 雷课程知识点暨面试题总结

讲师：Reythor 雷

16

即实现了该接口的 registerBeanDefinitions()方法。这个接口就是专门处理配置类的。而

@EnableFeignClients 注解的的 defaultConfiguration 与@FeignClient 注解中的 configuration 属

性都是配置类，就是由这个接口方法处理的。所以就从 FeignClientsRegistrar 类的方法

registerBeanDefinitions()入手分析。

【Q-02】关于 volatile 与 synchronized，很多时候会一起使用，为什么？请谈一下你的认识。

【RA】首先要清楚，在系统中存在这样的两类内存。一类是为每个线程单独分配的工作内

存，即高速缓存。一类是为当前应用（进程）分配的主内存。对于共享变量，其是同时存在

于每个线程的工作内存与主内存中的。一个线程若要修改共享变量的值，其首先需要从主内

存中将共享变量值读取到自己的工作内存，然后在自己的工作内存中进行修改。即对于共享

变量的修改是在各个线程的工作内存中进行的。而对于共享变量的读取，则是从主内存中读

取的。

为了使共享变量在线程的工作内存中修改后的值能够立即更新到进程主内存，就需要为

共享变量添加 volitile 修饰符，即 volitile 可以保证共享变量值对所有线程的“可见性”。

但在并发环境下对于共享变量的修改“有序性”就需要使用 synchronized 了。将对共享

变量的修改代码放入到 synchronized 语句块中，就可以保证了对共享变量修改的“有序性”。

将 synchronized 与 volatile 联合使用就可以保证了“我在修改时，你们都不能改。但我

改过了，你们都可以看到”。当然，若对主内存中的共享变量的某个时刻的值，同时有多个

线程读取到了各自的工作内存，其是通过“乐观锁”机制解决版本冲突问题的。

【Q-03】什么是迭代稳定性问题？请谈一下你的认识。

【RA】迭代稳定性问题其实就是共享集合迭代稳定性问题。其描述的问题是，在并发处理

的场景下，对某实例中共享集合的访问中，若在对该集合进行写操作的同时，又有线程对其

执行迭代访问，此时迭代访问的结果可能会出现稳定性问题。

为了解决这个问题，可以采用以下三种方案：

 读/写操作均添加读/写锁

 引入专门的只读集合

 集合替换

【Q-04】Spring Cloud 中 OpenFeign 的@EnableFeignClients 注解中 value、basePackages 与

basePackageClasses 属性均可以用于指定要扫描 Feign Client 的基本包。这三个属性值是什么

关系？请谈一下你的认识。

【RA】Spring Cloud 中 OpenFeign 的@EnableFeignClients 注解中 value、basePackages 与

basePackageClasses 属性均可以用于指定要扫描 Feign Client 的基本包，只要这三个属性都指

定了值，那么，这些指定的包均会扫描。

【Q-05】Spring Cloud 中 OpenFeign 的@EnableFeignClients 注解中 value、basePackages、

basePackageClasses 属性与 clients 属性均可以用于指定要扫描 Feign Client 的位置。这五个属

性值是什么关系？请谈一下你的认识。

【RA】Spring Cloud 中 OpenFeign 的@EnableFeignClients 注解中 value、basePackages、

basePackageClasses属性与clients属性均可以用于指定要扫描Feign Client的位置。其中value、

basePackages、basePackageClasses 属性用于指定要扫描的基本包，而 clients 属性用于指定与

Feign Client 同包的类或接口。若指定了 clients 属性，则用于指定基本包的属性将不起作用。 开课吧 Reythor 雷课程知识点暨面试题总结

讲师：Reythor 雷

17

【Q-06】Spring Cloud 中 OpenFeign 的@FeignClient 注解中 value、contextId、name 与 serviceId

属性均可以用于指定要生成的 Feign Client 的名称。这四个属性值是什么关系？请谈一下你

的认识。

【RA】Spring Cloud 中 OpenFeign 的@FeignClient 注解中 value、contextId、name 与 serviceId

属性均可以用于指定要生成的 Feign Client 的名称。这四个属性值若都指定了不同的值，那

么只会有一个起作用，它们的优先级由高到低分别是 contextId、value、name、serviceId。 

【Q-07】对于共享集合，为何有的需要考虑迭代稳定性而有的不需要？请谈一下你的看法。

【RA】对于共享集合，在并发环境下，若存在某些线程对其进行修改时，其它线程可能会

对其进行遍历迭代访问的情况，那么就需要考虑迭代稳定性问题。若不存在遍历迭代的情况，

就无需考虑。

【Q-08】Spring Cloud 中 OpenFeign 的 FeignContext 对于 Feign Client 的创建非常的重要。其 

中维护着一个重要集合 contexts，该集合中都保存了什么内容？请谈一下你的认识。 

【RA】Spring Cloud 中 OpenFeign 的 FeignContext 中维护着一个重要集合 contexts，该集合是

一个线程安全的 map。其 key 为每个@FeignClient 的 name 属性，即微服务名称，而 value

则为该@FeignClient 所对应的一个 Spring 子容器对象，该容器中存放着该 Feign Client 创建所

需要的所有对象。 

【Q-09】Spring Cloud 中 OpenFeign 的 FeignContext 对于 Feign Client 的创建非常的重要。其 

中维护着一个重要集合 configurations，该集合中都保存了什么内容？请谈一下你的认识。 

【RA】Spring Cloud 中 OpenFeign 的 FeignContext 中维护着一个重要集合 configurations，其

是一个线程安全的 map。其 key-value 分为两类：

 第一类只有一个，key 是字符串“default + 当前启动类的全限定性类名”，而 value

为@EnableFeignClients 中 configuration 的值；

 第二类可以有多个，key 为当前@FeignClient 的 name 属性名，即微服务名称，value

则为每个@FeignClient 的 configuration 的属性值。这一类 key-value 对会有很多，有

多少的@FeignClient 就会有多少的这类 key-value。 

【Q-10】在一个类或方法上出现的 synthetic 是什么意思？请谈一下你的认识。 

【RA】synthetic，合成的。当一个类或方法前出现了该关键字，则说明该类或方法是由编译

器自动生成的。这个关键字一般不是我们人为写到代码中的，而是由编译器编译生成的字节

码文件中。

例如，当一个内部类中的方法要访问外部类的 private 成员时，编译器会为该内部类方

法前自动添加上 synthetic 修饰符，表示该类中的方法可以访问到那个 private 成员。

编译器为什么要为其添加这个修饰符呢？因为对于编译器来说，无论是内部类还是外部

类，其编译出的字节码文件都是一个独立的文件。为了标识出这个内部类文件的方法与其它

类文件的方法的不同，编译器会为该类自动添加上这个修饰符，以使其可以访问到另一个类

的 private 成员。

当然，若一个方法是由编译器内部生成的，那么这个编译器生成的这个方法前也会自动

添加上 synthetic 关键字的。

【Q-11】Spring Cloud 中 OpenFeign 中创建的 Feign Client 是一个什么对象？请谈一下你的看 

法。 开课吧 Reythor 雷课程知识点暨面试题总结

讲师：Reythor 雷

18

【RA】Spring Cloud 中 OpenFeign 中创建的 Feign Client 是一个 JDK 的 Proxy 动态代理对象。

确切地说，这个 proxy 并不是 Feign Client 的代理对象，而是 Feign Client 与当前被调用的 Feign

方法结合体的代理对象。即当前 Feign Client 有多个 Feign 方法被调用，就会创建出多个 proxy

代理对象。当然，若当前某一个 Feign 方法同时被多个线程调用，那么就会创建出多个 proxy

代理对象。 

【Q-12】Spring Cloud 中 OpenFeign 中 Feign Client 的一个方法调用是如何发出去的？如果查 

看这个源码？请谈一下你的思路。 

【RA】Spring Cloud 中 OpenFeign 中创建的 Feign Client 是一个 JDK 的 Proxy 动态代理对象， 

所以若要解析 Feign 方法的调用，可以找到 JDK 的 Proxy 生成时的 InvocationHandler 实例的 

invoke()方法，该方法是 Feign 方法执行后系统立即调用的方法。