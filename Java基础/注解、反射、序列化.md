# 1.反射(Reflection)

## 1.1反射概念

### 1.1.1反射定义

反射是java被视为动态语言的关键，反射机制允许程序在执行期借助Reflection API取得任何类的内部信息，并能直接操作任意对象的内部属性及方法。

​                      Class c=Class.forName("java.lang.String")

加载完类之后，在堆内存的方法区中 就产生了一个Class类型的对象（**一个类只有一个Class对象**），**这个对象就包含了完整的类的结构信息**。我们可以通过这个对象看到类的结构。

### 1.1.2反射的优点和缺点

优点：可以实现动态创建对象和编译，体现出很大的灵活性

缺点：对性能有影响。使用反射基本上是一种解释操作，我们可以告诉JVM，我们希望做什么并且它满足我们的要求。这类操作总是慢于直接执行相同的操作。

### 1.1.3反射相关的主要API

- java.lang.Class：代表一个类
- java.lang.reflect.Method：代表类的方法
- java.lang.reflect.Field：代表类的成员变量
- java.lang.reflect.Constructor：代表类的构造器

## 1.2Class类

### 1.2.1Class类介绍

对于每个类而言，JRE都为其保留一个不变的Class类型的对象。一个Class对象包含了特定某个结构（class/interface/enum/annotation/primitive type/void/[])的有关信息。

- Class本身也是一个类
- Class对象只能由系统建立对象
- 一个加载的类在JVM中只会有一个Class实例
- 一个Class对象对应的是一个加载到JVM中的一个.class文件
- 通过Class可以完整地得到一个类中的所有被加载的结构
- Class类是Reflection的根源，针对任何你想动态加载、运行的类，唯有先获得相应的Class

### 1.2.2Class类的常用方法

![image-20200712181255192](C:\Users\kyn\AppData\Roaming\Typora\typora-user-images\image-20200712181255192.png)

## 1.3获取Class类的实例

- 若已知具体的类，通过类的class属性获取，该方法最为安全可靠，程序性能最高           

```java
    Class class=类名.class;
```

- 已知某个类的实例，调用该实例的getClass()方法获取Class对象

```java
   Class class=对象名.getClass();
```

- 已知一个类的全类名，且在该类的路径下，可通过Class类的静态方法forName()获取，可能抛出ClassNotFoundException

```java
    Class class=Class.forName("全类名");
```

- 内置基本数据类型可以直接用类名.Type
- 还可以利用ClassLoade



哪些类型可以有Class对象？

- class：外部类、成员（成员内部类、静态内部类）、局部内部类、匿名内部类
- interface：接口
- []：数组
- enum：枚举
- annotation：注解@interface
- primitive type：基本数据类型
- void



Java内存分析

![image-20200713203940137](C:\Users\kyn\AppData\Roaming\Typora\typora-user-images\image-20200713203940137.png)



类的加载过程

![image-20200713204101621](C:\Users\kyn\AppData\Roaming\Typora\typora-user-images\image-20200713204101621.png)

类的加载与ClassLoader的理解

![image-20200713204243665](C:\Users\kyn\AppData\Roaming\Typora\typora-user-images\image-20200713204243665.png)

什么时候会发生类的初始化

![image-20200713210452020](C:\Users\kyn\AppData\Roaming\Typora\typora-user-images\image-20200713210452020.png)



```
public class test {
    static{
        System.out.println("Main类被加载");
    }
    public static void main(String[] args) throws ClassNotFoundException {
        /*
        //主动引用
        Son son=new Son();    //Main类被加载
                              //Father类被加载
                              //Son类被加载
        */

        /*
        //通过反射加载
       Class cl= Class.forName("com.kong.reflection.test01.Son");//Main类被加载
                                                                 //Father类被加载
                                                                 //Son类被加载
       */


       /*
       //子类引用父类的静态变量，不会导致子类初始化
        System.out.println(Son.a);  //Main类被加载
                                    //Father类被加载
                                    //100
       */



       /*
       //通过数组定义类引用，不会触发类的初始化
       Son[] sons=new Son[5];//Main类被加载
       */

        //引用常量不会触发类的初始化
        System.out.println(Son.M);//Main类被加载
                                  //2
    }
}

class Father{

    static int a=100;

    static{
        System.out.println("Father类被加载");
    }
}

class Son extends Father{
    static{
        System.out.println("Son类被加载");
        b=200;
    }
    static int b=100;
    static final int M=2;
}
```



## 1.4类加载器

### 1.4.1类加载器的作用

![image-20200713220451665](C:\Users\kyn\AppData\Roaming\Typora\typora-user-images\image-20200713220451665.png)



![image-20200713220648793](C:\Users\kyn\AppData\Roaming\Typora\typora-user-images\image-20200713220648793.png)



![image-20200713220917214](C:\Users\kyn\AppData\Roaming\Typora\typora-user-images\image-20200713220917214.png)

![image-20200713221631402](C:\Users\kyn\AppData\Roaming\Typora\typora-user-images\image-20200713221631402.png)





# 2.注解(Annotation)

## 2.1什么是注解

- JDK 5中引入了源代码中的注解（annotation）这一机制。注解使得Java源代码中不但可以包含功能性的实现代码，还可以添加元数据（matedata）。

- 注解的功能类似于代码中的注释，所不同的是**注解不是提供代码功能的说明，而是实现程序功能的重要组成部分。**

- Java注解已经在很多框架中得到了广泛的使用，用来简化程序中的配置。

- **注解的本质就是一个继承了 Annotation 接口的接口**

-  **一个注解准确意义上来说，只不过是一种特殊的注释而已，如果没有解析它的代码，它可能连注释都不如。**

- 解析一个类或者方法的注解往往有两种形式：一种是编译期直接的扫描，一种是运行期反射。

  ​        **编译期直接的扫描** - 编译器的扫描指的是编译器在对 java 代码编译字节码的过程中会检测到某个类或者方法被一些注解修饰，这时它就会对于这些注解进行某些处理。这种情况只适用于 JDK 内置的注解类。

  ​        **运行期的反射** - 如果要自定义注解，Java 编译器无法识别并处理这个注解，它只能根据该注解的作用范围来选择是否编译进字节码文件。如果要处理注解，必须利用反射技术，识别该注解以及它所携带的信息，然后做相应的处理。

### 2.1.1Annotation的作用

- 不是程序本身，可对程序做出解释
- **可以被其他程序（比如：编译器等）读取**

### 2.1.2Annotation的格式

​        注解是以“@注解名称”在代码中存在的，还可以添加一些参数值，例如:@SuppressWarnings(value="unchecked")

### 2.1.3Annotation在哪里使用

可以附加在package,class,method,field等上面，相当于给他们添加了额外的辅助信息，我们可以通过反射机制编程实现对这些元数据的访问

### 2.1.4注解分类



## 2.2内置注解

- 定义：即Java内部已经实现好的注解
- 类型：`Java`中 内置的注解有5类，具体包括：

<img src="https://imgconvert.csdnimg.cn/aHR0cDovL3VwbG9hZC1pbWFnZXMuamlhbnNodS5pby91cGxvYWRfaW1hZ2VzLzk0NDM2NS02YWU4YWJiMjVmNmMwMzliLnBuZz9pbWFnZU1vZ3IyL2F1dG8tb3JpZW50L3N0cmlwJTdDaW1hZ2VWaWV3Mi8yL3cvMTI0MA" alt="img" style="zoom:50%;" />

### 2.2.1@Deprecated

- 定义：过时注解，定义在java.lang.Deprecated中
- 作用：标记已过时 & 被抛弃的元素（类、方法、属性等），不鼓励程序员使用这样的角色，但可以被使用。
- 具体使用

```
// 用 注解@Deprecated 标记类中已过时的 方法Hello()
public class Buyer2   {

    @Deprecated
    public void Hello(){
        System.out.println("Hello 2015!");
    }
}
```

使用该类中被 `@Deprecated` 作用的方法时，`IDE`会提示该方法已过时 / 抛弃，该方法上出现划线。

<img src="https://imgconvert.csdnimg.cn/aHR0cDovL3VwbG9hZC1pbWFnZXMuamlhbnNodS5pby91cGxvYWRfaW1hZ2VzLzk0NDM2NS05OTU2NjdiOGM1NDIyZTdjLnBuZz9pbWFnZU1vZ3IyL2F1dG8tb3JpZW50L3N0cmlwJTdDaW1hZ2VWaWV3Mi8yL3cvMTI0MA" alt="img" style="zoom:50%;" />



> 注意： `@Deprecated` 这个注解类型和 javadoc 中的 `@deprecated` 这个 tag 是有区别的：前者是 java 编译器识别的；而后者是被 javadoc 工具所识别用来生成文档（包含程序成员为什么已经过时、它应当如何被禁止或者替代的描述）。

### 2.2.2@Override

- 定义：重写注解，定义在java.lang.Override中
- 作用：只适用于修辞方法，标记该方法是重写父类的方法
- 具体使用

```
// UserDao 接口
public interface IUserDao {
	User loadUserByUsername(String username);
	// ...
}
// UserDao 实现类
public class UserDao implement IUserDao {
	@Override
	public User loadUserByUsername(String username) {
		// TODO: 
	}
	// ...
}
```



### 2.2.3@SuppressWarnings

- 定义：阻止警告注解，定义在java.lang.SuppressWarnings中
- 作用：标记的元素会阻止编译器发出警告提醒

> 主要应用于开发者需要忽略警告时

- 该注解需要添加一个参数才能正确使用，这些参数都是定义好的，我们可以直接拿来使用

​           @SuppressWarnings("all")

​           @SuppressWarnings("unchecked")

​           @SuppressWarnings(value={"unchecked","deprecation"})

​            等等......

参数说明：

1. `deprecation` ：使用了不赞成使用的类或方法时的警告；
2. `unchecked` ：执行了未检查的转换时的警告，例如当使用集合时没有用泛型 (Generics) 来指定集合保存的类型;
3. `fallthrough` ：当 Switch 程序块直接通往下一种情况而没有 Break 时的警告;
4. `path` ：在类路径、源文件路径等中有不存在的路径时的警告;
5. `serial` ：当在可序列化的类上缺少 serialVersionUID 定义时的警告;
6. `finally` ：任何 finally 子句不能正常完成时的警告;
7. `all` ：关于以上所有情况的警告。

### 2.2.4@SafeVarargs

- 定义：参数安全类型注解

> `Java` 1.7 后引入

- 作用：

  - 提醒开发者不要用参数做不安全的操作 & 阻止编译器产生 `unchecked`警告
  - **告诉编译器，在可变长参数中的泛型是类型安全的。可变长参数是使用数组存储的，而数组和泛型不能很好的混合使用。**简单的说，数组元素的数据类型在编译和运行时都是确定的，而泛型的数据类型只有在运行时才能确定下来。因此，当把一个泛型存储到数组中时，编译器在编译阶段无法确认数据类型是否匹配，因此会给出警告信息；即如果泛型的真实数据类型无法和参数数组的类型匹配，会导致 `ClassCastException` 异常。

  ```
  public class SafeVarargsAnnotationDemo {
      /**
       * 此方法实际上并不安全，不使用此注解，编译时会告警
       */
      @SafeVarargs
      static void wrongMethod(List<String>... stringLists) {
          Object[] array = stringLists;
          List<Integer> tmpList = Arrays.asList(42);
          array[0] = tmpList; // 语法错误，但是编译不告警
          String s = stringLists[0].get(0); // 运行时报 ClassCastException
      }
  
      public static void main(String[] args) {
          List<String> list = new ArrayList<>();
          list.add("A");
          list.add("B");
  
          List<String> list2 = new ArrayList<>();
          list.add("1");
          list.add("2");
  
          wrongMethod(list, list2);
      }
  }
  
  ```

  以上代码，如果不使用 `@SafeVarargs` ，编译时会告警

  ```
  [WARNING] /D:/Codes/ZP/Java/javacore/codes/basics/src/main/java/io/github/dunwu/javacore/annotation/SafeVarargsAnnotationDemo.java: 某些输入文件使用了未经检查或不安全的操作。
  [WARNING] /D:/Codes/ZP/Java/javacore/codes/basics/src/main/java/io/github/dunwu/javacore/annotation/SafeVarargsAnnotationDemo.java: 有关详细信息, 请使用 -Xlint:unchecked 重新编译。
  
  ```

  

- `@SafeVarargs` 注解使用范围：

  - `@SafeVarargs` 注解可以用于构造方法。
  - `@SafeVarargs` 注解可以用于 `static` 或 `final` 方法。

- 具体使用

```
// 以下是官方例子
// 虽然编译阶段不报错，但运行时会抛出 ClassCastException 异常
// 所以该注解只是作提示作用，但是实际上还是要开发者自己处理问题
    @SafeVarargs // Not actually safe!
    static void m(List<String>... stringLists) {
    Object[] array = stringLists;
    List<Integer> tmpList = Arrays.asList(42);
    array[0] = tmpList; // Semantically invalid, but compiles without warnings
    String s = stringLists[0].get(0); // Oh no, ClassCastException at runtime!
}

```

### 2.2.5@FunctionalInterface

- 定义：函数式接口注解，**用于指示被修饰的接口是函数式接口。**

> `Java` 1.8 后引入的新特性
>
> 需要注意的是，如果一个接口符合"函数式接口"定义，不加 `@FunctionalInterface` 也没关系；但如果编写的不是函数式接口，却使用 `@FunctionInterface`，那么编译器会报错。

​        什么是函数式接口？

​        **函数式接口(Functional Interface)就是一个有且仅有一个抽象方法，但是可以有多个非抽象方法的接口**。函数式接口可以被隐式转换为 lambda 表达式。

> 函数式接口 (Functional Interface) = 1个具有1个方法的普通接口

​        函数式接口的特点：

​                接口有且只能有个一个抽象方法（抽象方法只有方法定义，没有方法体）。

​                不能在接口中覆写 Object 类中的 public 方法（写了编译器也会报错）。

​                允许有 default 实现方法。

- 作用：表示该接口 = 函数式接口

- 具体使用

```
public class FunctionalInterfaceAnnotationDemo {

    @FunctionalInterface
    public interface Func1<T> {
        void printMessage(T message);
    }

    /**
     * @FunctionalInterface 修饰的接口中定义两个抽象方法，编译时会报错
     * @param <T>
     */
    /*@FunctionalInterface
    public interface Func2<T> {
        void printMessage(T message);
        void printMessage2(T message);
    }*/

    public static void main(String[] args) {
        Func1 func1 = message -> System.out.println(message);
        func1.printMessage("Hello");
        func1.printMessage(100);
    }
}

```

## 2.3元注解

- **元注解的作用就是用于定义其它的注解**，java定义了4个标准的meta-annotation类型，他们被用来提供对其他annotation类型说明。
- 这些类型和他们所支持的类在Java.lang.annotation中可以找到。

![img](https://imgconvert.csdnimg.cn/aHR0cDovL3VwbG9hZC1pbWFnZXMuamlhbnNodS5pby91cGxvYWRfaW1hZ2VzLzk0NDM2NS1jMmQ3NzM2NzQ5ZWQ5NmE3LnBuZz9pbWFnZU1vZ3IyL2F1dG8tb3JpZW50L3N0cmlwJTdDaW1hZ2VWaWV3Mi8yL3cvMTI0MA)

### 2.3.1@Retention

- `@Retention`保留注解，指明了注解的保留级别，用于描述注解的生命周期
- `@Retention` 源码

```
@Documented
@Retention(RetentionPolicy.RUNTIME)
@Target(ElementType.ANNOTATION_TYPE)
public @interface Retention {
    RetentionPolicy value();
}

```

- `RetentionPolicy` 是一个枚举类型，它定义了被 `@Retention` 修饰的注解所支持的保留级别：

  - `RetentionPolicy.SOURCE` - 标记的注解仅在源文件中有效，编译器会忽略。
  - `RetentionPolicy.CLASS` - 标记的注解在 class 文件中有效，JVM 会忽略。
  - `RetentionPolicy.RUNTIME` - 标记的注解在运行时有效。

  **SOURCE<CLASS<RUNTIME**

### 2.3.2@Documented

[`@Documented`](https://docs.oracle.com/javase/8/docs/api/java/lang/annotation/Documented.html) java文档注解，说明该注解将被包含在javadoc中（默认情况下，注释不包含在 Javadoc 中）

### 2.3.3@Target

- `@Target`目标注解，指定注解可以修饰的元素类型。用于描述注解的使用范围
- `@Target` 源码

```
@Documented
@Retention(RetentionPolicy.RUNTIME)
@Target(ElementType.ANNOTATION_TYPE)
public @interface Target {
    ElementType[] value();
}
```

- `ElementType` 是一个枚举类型，它定义了被 `@Target` 修饰的注解可以应用的范围：
  - `ElementType.ANNOTATION_TYPE` - 标记的注解可以应用于注解类型。
  - `ElementType.CONSTRUCTOR` - 标记的注解可以应用于构造函数。
  - `ElementType.FIELD` - 标记的注解可以应用于字段或属性。
  - `ElementType.LOCAL_VARIABLE` - 标记的注解可以应用于局部变量。
  - `ElementType.METHOD` - 标记的注解可以应用于方法。
  - `ElementType.PACKAGE` - 标记的注解可以应用于包声明。
  - `ElementType.PARAMETER` - 标记的注解可以应用于方法的参数。
  - `ElementType.TYPE` - 标记的注解可以应用于类的任何元素。

### 2.3.4@Inherited

`@Inherited`继承注解，表示注解类型可以被继承（子类可以继承父类中的该注解）。

表示自动继承注解类型。 如果注解类型声明中存在 `@Inherited` 元注解，则注解所修饰类的所有子类都将会继承此注解。

> 前提：子类没有被任何注解应用
>
> `@Inherited` 注解类型是被标注过的类的子类所继承。类并不从它所实现的接口继承注解，方法并不从它所覆写的方法继承注解。
>
> 此外，当 `@Inherited` 类型标注的注解的 `@Retention` 是 `RetentionPolicy.RUNTIME`，则反射 API 增强了这种继承性。如果我们使用 `java.lang.reflect` 去查询一个 `@Inherited` 类型的注解时，反射代码检查将展开工作：检查类和其父类，直到发现指定的注解类型被发现，或者到达类继承结构的顶层。

具体使用：

```
// 元注解@Inherited 作用于 注解Carson_Annotation
@Inherited
public @interface Carson_Annotation {
}


// 注解Carson_Annotation 作用于A类
@Carson_Annotation
public class A {
  }

// B类继承了A类，即B类 = A类的子类，且B类没被任何注解应用
// 那么B类继承了A类的注解 Carson_Annotation
public class B extends A {}

```

### 2.3.5@Repeatable

- `@Repeatable`可重复注解，表示注解可以重复使用。

> `Java` 1.8后引进

- 作用：使得作用的注解可以取多个值
- 具体使用

```
// 1. 定义 容器注解 @ 职业
public @interface Job {
    Person[]  value();
}
<-- 容器注解介绍 -->
// 定义：本身也是一个注解
// 作用：存放其它注解
// 具体使用：必须有一个 value 属性；类型 = 被 @Repeatable 注解的注解数组
// 如本例中，被 @Repeatable 作用 = @Person ，所以value属性 = Person []数组

// 2. 定义@Person 
// 3. 使用@Repeatable 注解 @Person
// 注：@Repeatable 括号中的类 = 容器注解
@Repeatable（Job.class）
public @interface Person{
    String role default "";
}

// 在使用@Person（被@Repeatable 注解 ）时，可以取多个值来解释Java代码
// 下面注解表示：Carson类即是产品经理，又是程序猿
@Person(role="coder")
@Person(role="PM")
public class Carson{

}

```



## 2.4自定义注解

使用 `@interface` 自定义注解时，自动继承了 `java.lang.annotation.Annotation` 接口，由编译程序自动完成其他细节。在定义注解时，不能继承其他的注解或接口。

- `@interface` 用来声明一个注解，其中的每一个方法实际上是声明了一个配置参数。方法的名称就是参数的名称，返回值类型就是参数的类型（返回值类型只能是基本类型、Class、String、enum）。
- 可以通过 `default` 来声明参数的默认值。

### 2.4.1注解格式

```
public @interface 注解名 {注解属性}
```

具体使用：

```
@Documented
@Target({ElementType.FIELD, ElementType.PARAMETER})
@Retention(RetentionPolicy.RUNTIME)
public @interface RegexValid {}
```

> 说明：
>
> - 上面的代码中定义了一个名为 `@RegexValid` 的注解。
> - `@Documented` 表示 `@RegexValid` 应该使用 javadoc。
> - `@Target({ElementType.FIELD, ElementType.PARAMETER})` 表示 `@RegexValid` 可以在类成员或方法参数上修饰。
> - @Retention(RetentionPolicy.RUNTIME) 表示 `@RegexValid` 在运行时有效。

此时，我们已经定义了一个没有任何属性的注解，如果到此为止，它仅仅是一个标记注解。作为正则工具，没有属性可什么也做不了。接下来，我们将为它添加注解属性。

### 2.4.2注解属性

```
[访问级别修饰符] [数据类型] 名称() default 默认值;
```

例如，我们要定义在注解中定义一个名为 value 的字符串属性，其默认值为空字符串，访问级别为默认级别，那么应该定义如下：

```
String value() default "";
```

> 注意：**在注解中，我们定义属性时，属性名后面需要加 `()`**。

定义注解属性有以下要点：

- 访问修饰符只能使用 `public` 或者 `default（默认的、友好的）`
- 返回值类型就是参数的类型且只能为 `八种基本数据类型` 、 `Class` 、 `String` 、 `Enum` 、`Annotations类型`以及上述类型所组成的 **数组**
- 通过 `default` 关键字声明参数的默认值。
- 如果只有一个参数成员最好命名为 `value()`,在使用注解时，指定的value的值可以不指定属性名称。
- 注解元素必须有确定的值，要么在定义注解元素时默认值指定，要么使用此注解时指定。非基本类型注解元素的值不可为 `null`

```java
/**
 * 基本的注解声明，只有一个属性
 */
public @interface AnnotationOne {
    String value() default "";
}

/**
 * 基本的注解使用
 */
@AnnotationOne("AnnotationOneTest")
public class AnnotationOneTest {
    
}
```







![img](https://user-gold-cdn.xitu.io/2019/4/5/169eda58cb97c616?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)



# 3.序列化