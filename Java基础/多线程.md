# 1.基本概念

## 1.1普通方法调用和多线程

![image-20200718153559006](多线程.assets/image-20200718153559006.png)

## 1.2程序、进程和线程

程序是指令和数据的有序集合，其本身没有任何运行的含义，是一个静态的概念

进程是执行程序的一次执行过程，它是一个动态的概念。是系统资源分配的单位

通常在一个进程中可以包含若干个线程，当然一个进程中至少有一个线程，不然没有存在的意义。线程是CPU调度和执行的单位

> 注意：很多线程是模拟出来的，真正的多线程是指有多个cpu,即多核，如服务器。如果是模拟出来的多线程，即在一个cpu的情况下，在同一个时间点，cpu只能执行一个代码，因为切换的很快，所以就有同时执行的错局。

# 2.线程的创建和使用

三种创建方式：

1. **继承Thread类**
2. **实现Runnable接口**
3. **实现Callable接口**

## 2.1继承Thread类

### 2.1.1创建步骤

![image-20200718214620963](多线程.assets/image-20200718214620963.png)





## 2.2实现Runnable接口

![image-20200718220713211](多线程.assets/image-20200718220713211.png)





![image-20200718221255467](多线程.assets/image-20200718221255467.png)



案例

![image-20200718223326341](多线程.assets/image-20200718223326341.png)





## 2.3实现Callable接口

![image-20200718224531423](多线程.assets/image-20200718224531423.png)

# 3.线程的状态

![image-20200718233346109](多线程.assets/image-20200718233346109.png)



![image-20200718233512611](多线程.assets/image-20200718233512611.png)

线程状态观测

![image-20200719164214974](多线程.assets/image-20200719164214974.png)

```java
public class StateTest {
    public static void main(String[] args) {
        Thread thread=new Thread(()->{
            for (int i = 0; i < 5; i++) {
                try {
                    Thread.sleep(1000);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            System.out.println("线程执行完成");
        });

        //观察状态
        Thread.State state = thread.getState();
        System.out.println(state);

        //观察启动后
        thread.start();
        state=thread.getState();
        System.out.println(state);

        //只要线程不终止，就一直输出状态
        while(thread.getState()!=Thread.State.TERMINATED){
            try {
                Thread.sleep(100);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            state=thread.getState();
            System.out.println(state);
        }
    }
}
```



# 4.线程方法

![image-20200718233637408](多线程.assets/image-20200718233637408.png)

停止线程

![image-20200718233713788](多线程.assets/image-20200718233713788.png)

线程休眠

![image-20200718233836965](多线程.assets/image-20200718233836965.png)



线程礼让(yield)

![image-20200719162143445](多线程.assets/image-20200719162143445.png)

线程强制执行（join)

![image-20200719162720294](多线程.assets/image-20200719162720294.png)



线程优先级

![image-20200719172358726](多线程.assets/image-20200719172358726.png)



守护(daemon)线程

![image-20200719172557524](多线程.assets/image-20200719172557524.png)

使用`setDaemon(Boolean b)`设置某线程为守护线程，默认为false表示时用户线程。正常的线程都是用户线程。

# 5.线程的生命周期

# 6.线程的同步

多个线程操作同一个资源

并发：同一个对象被多个线程同时操作

处理多线程问题时，多个线程访问同一个对象，并且某些线程还想修改这个对象，这时候我们就需要线程同步。线程同步其实就是一种等待机制，多个需要同时访问此对象的线程进入这个对象的等待池形成队列，等待前面线程使用完毕，下一个线程才能使用。

![image-20200719174648384](多线程.assets/image-20200719174648384.png)

三大不安全案例

 买火车票的例子

```java
public class ThreadTest implements Runnable {

    private int ticketNum = 5;
    @Override
    public void run() {
        while(true){
            if(ticketNum <= 0){
                break;
            }
            try {
                Thread.sleep(100);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            System.out.println(Thread.currentThread().getName()+"拿到了第"+(ticketNum--)+"票");
        }
    }

}

public class Project01 {
    public static void main(String[] args) {
          ThreadTest tt=new ThreadTest();
          new Thread(tt,"张三").start();
          new Thread(tt,"李四").start();
          new Thread(tt,"王五").start();
    }
}


//执行结果
王五拿到了第5票
张三拿到了第3票
李四拿到了第4票
李四拿到了第2票
张三拿到了第2票
王五拿到了第2票
张三拿到了第1票
李四拿到了第-1票
王五拿到了第0票

//多个线程操作同一个资源时，出现重复或者负数的情况。
```

银行取款案例

```java
public class UnsafeBank {
    public static void main(String[] args) {
        Account account=new Account("zhangsan",100);
        Drawing drawing=new Drawing(account,50,"zhangsan");
        Drawing drawing1=new Drawing(account,100,"lisi");
        drawing.start();
        drawing1.start();
    }
}
//账户
class Account{
    private String name;
    private double money;

    public Account(String name, double money) {
        this.name = name;
        this.money = money;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public double getMoney() {
        return money;
    }

    public void setMoney(double money) {
        this.money = money;
    }
}
//银行：模拟取款
class Drawing extends Thread{
    Account account;
    double drawingMoney;

    public Drawing(Account account, double drawingMoney,String name) {
        super(name);
        this.account = account;
        this.drawingMoney = drawingMoney;
    }

    @Override
    public void run() {
        try {
            Thread.sleep(1000);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        if(account.getMoney()-drawingMoney<0){
            System.out.println("卡内余额不足");
            return;
        }
        System.out.println(Thread.currentThread().getName()+"取了"+drawingMoney+"元");
        account.setMoney(account.getMoney()-drawingMoney);
        System.out.println("卡内还剩"+account.getMoney()+"元");
    }
}

//执行结果
zhangsan取了50.0元
卡内还剩50.0元
lisi取了100.0元
卡内还剩-50.0元
    
//在执行结果中我们发现账户余额出现了负数
```

线程不安全的集合

```java
public class UnsafeList {
    public static void main(String[] args) {
        List<String> list=new ArrayList<>();
        for (int i = 0; i < 10000; i++) {
            new Thread(()->{
                list.add(Thread.currentThread().getName());
            }).start();
        }
        try {
            Thread.sleep(1000);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        System.out.println(list.size());
    }
}

//运行该程序，我们会发现执行结果有时不正确，插入的数据个数不是10000；
```



![image-20200719185252927](多线程.assets/image-20200719185252927.png)

同步方法和同步块

![image-20200719215424879](多线程.assets/image-20200719215424879.png)

![image-20200719215045416](多线程.assets/image-20200719215045416.png)

死锁

![image-20200719222717204](多线程.assets/image-20200719222717204.png)

# 7.线程 的通信

